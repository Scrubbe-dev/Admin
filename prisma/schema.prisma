generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                         String                         @id @default(uuid())
  email                      String                         @unique
  passwordHash               String?
  firstName                  String?
  lastName                   String?
  profileImage               String?
  isVerified                 Boolean                        @default(false)
  isActive                   Boolean                        @default(true)
  lastLogin                  DateTime?
  apiKeyDuration             DateTime                       @default(now())
  createdAt                  DateTime                       @default(now())
  updatedAt                  DateTime                       @updatedAt
  // business                   Business?
  apiKey                     String?                        @default(cuid())
  role                       Role                           @default(USER)
  passwordChangedAt          DateTime?
  username                   String?
  accountType                AccountType?
  oauthprovider              OAuthProvider?
  registerdWithOauth         Boolean                        @default(false)
  oauthProvider_uuid         String?
  scopes                     String[]                       @default(["api-key:create"])
  scrubbe_apikey             ApiKey[]
  ConversationParticipant    ConversationParticipant[]
  DetectionRule              DetectionRule[]
  developer                  Developer?
  Graph                      Graph[]
  Incident                   Incident[]
  IncidentComment            IncidentComment[]
  IncidentTicket             IncidentTicket[]
  Invites                    Invites[]
  Message                    Message[]
  PlaybookExecution          PlaybookExecution[]
  ProjectConfiguration       ProjectConfiguration[]
  refreshToken               RefreshToken[]
  resetTokens                ResetToken[]
  VerificationOTP            VerificationOTP?
  Customer                   Customer[]                     @relation("CustomerToUser")
  userThirdpartyIntegration  UserThirdpartyIntegration[]
  integrated                 BusinessNotificationChannels[]
  escalatedIncidentsReceived EscalatedIncident[]            @relation("UserEscalatedTo")
  escalatedIncidentsMade     EscalatedIncident[]            @relation("UserEscalatedBy")
  Imssetup                   Imssetup[]
  createdIncidentTickets IncidentTicket[] @relation("IncidentTicketCreator")
  customers EndCustomer[] @relation("CompanyUserToCustomers")
  businessId String?  // Add this field
  business   Business? @relation(fields: [businessId], references: [id])
  EndCustomerIncident EndCustomerIncident[]
  EndCustomer EndCustomer[]
  OnCallTeamMember OnCallTeamMember[]
  @@index([apiKey])
}

model ResolveIncident {
  id               String         @id @default(uuid())
  incidentTicketId String         @unique
  incidentTicket   IncidentTicket @relation(fields: [incidentTicketId], references: [id])

  causeCategory CauseCategory
  rootCause     String
  why1          String
  why2          String
  why3          String
  why4          String
  why5          String

  temporaryFix String
  permanentFix String

  knowledgeTitleInternal      String
  knowledgeSummaryInternal    String
  identificationStepsInternal String
  resolutionStepsInternal     String
  preventiveMeasuresInternal  String
  knowledgeTagsInternal       String[]

  knowledgeTitleCustomer   String?
  knowledgeSummaryCustomer String?

  followUpTask             String
  followUpOwner            String
  followUpDueDate          DateTime
  followUpStatus           FollowUpStatus
  followUpTicketingSystems BusinessPrefferedIntegration[]

  communicationChannel COMMUNICATION_CHANNEL
  targetStakeholders   String[]
  messageContent       String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Developer {
  id             String   @id @default(uuid())
  experience     String?
  githubUsername String?
  jobTitle       String?
  userId         String   @unique
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  user           User     @relation(fields: [userId], references: [id])
}

model ApiKey {
  id          String            @id @default(cuid())
  keyHash     String            @unique
  version     Int
  environment APIkeyEnvironment
  name        String
  userId      String
  scopes      String[]
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  expiresAt   DateTime?
  isActive    Boolean           @default(true)
  lastUsed    DateTime?
  user        User              @relation(fields: [userId], references: [id])
}









// Payment pricing plan section start

model Plan {
  id          String      @id @default(cuid())
  name        String
  type        PlanType
  price       Float
  currency    String      @default("usd")
  interval    Interval
  description String?
  features    String[]    // JSON array of features
  stripePriceId String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  subscriptions Subscription[]
}

model Subscription {
  id                String            @id @default(cuid())
  customerId        String
  customer          Customer          @relation(fields: [customerId], references: [id])
  planId            String
  plan              Plan              @relation(fields: [planId], references: [id])
  status            SubscriptionStatus
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime
  cancelAtPeriodEnd Boolean           @default(false)
  quantity          Int
  trialEnd          DateTime?
  metadata          Json?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
}

enum PlanType {
  STARTER
  GROWTH
  PRO
  ENTERPRISE
}

enum Interval {
  MONTH
  YEAR
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
  INCOMPLETE
  INCOMPLETE_EXPIRED
  TRIALING
}


// Payment pricing plan section end















model Business {
  id   String  @id @default(uuid())
  name String?

  incidentEmail String? @unique
  subdomain     String? @unique

  industry                   String?
  primaryRegion              String?
  logo                       String?
  address                    String?
  companySize                String?
  companyPurpose             String?
  purpose                    String?
  dashBoardId                String?                      @unique
  userId                     String?                      @unique
  createdAt                  DateTime                     @default(now())
  updatedAt                  DateTime                     @updatedAt
  // user                       User                         @relation(fields: [userId], references: [id])
  dashboard                  BusinessDashboard?           @relation("BusinessToDashboard")
  IncidentTicket             IncidentTicket[]
  invites                    Invites[]
  IncidentTicketNotification IncidentTicketNotification[]
  thirdpartyIntegrations     UserThirdpartyIntegration[]
  EndCustomerIncident EndCustomerIncident[]
  User User[]
}

model BusinessDashboard {
  id                   String                         @id @default(uuid())
  createdAt            DateTime                       @default(now())
  updatedAt            DateTime                       @updatedAt
  businessId           String                         @unique
  colorAccent          String                         @default("#4A90E2")
  defaultDashboard     DashboardType                  @default(SCRUBBE_DASHBOARD_SOUR)
  prefferedIntegration BusinessPrefferedIntegration[] @default([JIRA])
  notificationChannels BusinessNotificationChannels[] @default([EMAIL])
  defaultPriority      Priority[]                     @default([MEDIUM])
  business             Business                       @relation("BusinessToDashboard", fields: [businessId], references: [id])
}

model Imssetup {
  id             String   @id @default(uuid())
  name           String?
  incidentEmail  String?  @unique
  subdomain      String?  @unique
  industry       String?
  primaryRegion  String?
  logo           String?
  address        String?
  companySize    String?
  companyPurpose String?
  purpose        String?
  dashBoardId    String?  @unique
  userId         String   @unique
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relationships
  user                        User                         @relation(fields: [userId], references: [id])
  dashboard                   ImssetupDashboard?           @relation("ImssetupToDashboard")
  incidentTickets             IncidentTicket[]
  invites                     Invites[]
  incidentTicketNotifications IncidentTicketNotification[]
  thirdpartyIntegrations      UserThirdpartyIntegration[]
}

model ImssetupDashboard {
  id                   String                         @id @default(uuid())
  createdAt            DateTime                       @default(now())
  updatedAt            DateTime                       @updatedAt
  imssetupId           String                         @unique
  colorAccent          String                         @default("#4A90E2")
  defaultDashboard     DashboardType                  @default(SCRUBBE_DASHBOARD_SOUR)
  prefferedIntegration BusinessPrefferedIntegration[] @default([JIRA])
  notificationChannels BusinessNotificationChannels[] @default([EMAIL])
  defaultPriority      Priority[]                     @default([MEDIUM])
  imssetup             Imssetup                       @relation("ImssetupToDashboard", fields: [imssetupId], references: [id])
}

model Invites {
  id                        String                      @id @default(uuid())
  firstName                 String?
  lastName                  String?
  email                     String                      @unique
  role                      Role
  accessPermissions         AccessPermissions[]
  sentById                  String
  createdAt                 DateTime                    @default(now())
  updatedAt                 DateTime                    @updatedAt
  accepted                  Boolean                     @default(false)
  acceptedAt                DateTime?
  stillAMember              Boolean                     @default(true)
  status                    InviteStatus                @default(PENDING)
  userId                    String?
  IncidentTicket            IncidentTicket[]
  business                  Business                    @relation(fields: [sentById], references: [id])
  user                      User?                       @relation(fields: [userId], references: [id])
  userThirdpartyIntegration UserThirdpartyIntegration[]
  Imssetup                  Imssetup[]

  @@index([sentById])
}

model VerificationOTP {
  id        String   @id @default(uuid())
  code      String
  expiresAt DateTime
  used      Boolean  @default(false)
  userId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  sentTo    String   @unique
  user      User     @relation(fields: [userId], references: [id])
}

model ResetToken {
  id        String         @id @default(uuid())
  userId    String
  email     String
  token     String
  type      ResetTokenType
  expiresAt DateTime
  createdAt DateTime       @default(now())
  usedAt    DateTime?
  user      User           @relation(fields: [userId], references: [id])

  @@index([token])
  @@index([userId])
  @@index([type])
  @@index([expiresAt])
}

model Graph {
  id        String    @id @default(uuid())
  userId    String
  type      GraphType
  data      Json
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user      User      @relation(fields: [userId], references: [id])

  @@unique([userId, type])
}

model WaitingUser {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  fullName  String
  email     String   @unique @db.VarChar(255)
  company   String
  message   String?
  role      String

  @@index([email])
  @@index([createdAt])
}

model Admin {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email     String   @unique @db.VarChar(255)
  password  String
  isActive  Boolean  @default(true)

  @@index([email])
}

model RefreshToken {
  id              String    @id @default(uuid())
  userId          String
  token           String    @unique
  expiresAt       DateTime
  createdAt       DateTime  @default(now())
  revokedAt       DateTime?
  replacedByToken String?
  ipAddress       String?
  userAgent       String?
  user            User      @relation(fields: [userId], references: [id])
}

model SecurityEvent {
  id         String    @id @default(uuid())
  timestamp  DateTime  @default(now())
  source     String
  type       String
  severity   Int       @default(0)
  rawData    Json
  processed  Boolean   @default(false)
  alertid    String?
  customerId String?
  alert      Alert?    @relation(fields: [alertid], references: [id])
  customer   Customer? @relation(fields: [customerId], references: [id])

  @@index([source, type])
  @@index([timestamp])
}

model Alert {
  id        String          @id @default(uuid())
  createdAt DateTime        @default(now())
  ruleId    String
  status    AlertStatus     @default(OPEN)
  severity  Int
  rule      DetectionRule   @relation(fields: [ruleId], references: [id])
  events    SecurityEvent[]
  incidents Incident[]      @relation("AlertToIncident")

  @@index([status])
}

model Incident {
  id               String              @id @default(uuid())
  title            String
  description      String
  priority         Priority            @default(MEDIUM)
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
  customerId       String?
  assigneeId       String?
  incidentTicketId String?
  status           IncidentStatus      @default(OPEN)
  conversationId   String?
  assignee         User?               @relation(fields: [assigneeId], references: [id])
  customer         Customer?           @relation(fields: [customerId], references: [id])
  IncidentTicket   IncidentTicket?     @relation(fields: [incidentTicketId], references: [id])
  playbooks        PlaybookExecution[]
  alerts           Alert[]             @relation("AlertToIncident")

  @@index([priority, createdAt])
}

// ===================== START INCIDENT TICKET ==================

model IncidentTicket {
  id              String            @id @default(uuid())
  template        IncidentTemplate? @default(NONE)
  userName        String
  reason          String
  assignedToEmail String?           @map("assignedTo")
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  ticketId        String            @unique
  status          IncidentStatus    @default(OPEN)

  assignedById String
  createdFrom  String? // ticket may have been created from slack, email, github etc

  // SLA targets
  slaTargetAck        DateTime?
  slaTargetResolve    DateTime?
  firstAcknowledgedAt DateTime?
  resolvedAt          DateTime?
  closedAt            DateTime?
  slaBreachType       SLABreachType?

  // SLA Monitoring fields
  slaResponseHalfNotified Boolean @default(false)
  slaResolveHalfNotified Boolean @default(false)
  slaResponseBreachNotified Boolean @default(false)
  slaResolveBreachNotified Boolean @default(false)
  slaSeverity String? // Store the severity for SLA calculations
  slaResponseTimeMinutes Int? // Store the response time in minutes
  slaResolveTimeMinutes Int? // Store the resolve time in minutes
  sLABreachAuditLog   SLABreachAuditLog[]


    // Add these fields for MTTR monitoring
  mttrTargetAck DateTime?
  mttrTargetResolve DateTime?
  mttrResponseHalfNotified Boolean @default(false)
  mttrResolveHalfNotified Boolean @default(false)
  mttrResponseBreachNotified Boolean @default(false)
  mttrResolveBreachNotified Boolean @default(false)

  // Add this field to track ticket creator
  createdById String?
  createdBy User? @relation("IncidentTicketCreator", fields: [createdById], references: [id])

  recommendedActions DetermineAction[]
  riskScore          Int               @default(20)
  businessId         String?
  priority           Priority          @default(LOW)

  conversation Conversation?
  comments     IncidentComment[]

  Incident                   Incident[]
  assignedBy                 User?                          @relation(fields: [assignedById], references: [id])
  assignedTo                 Invites?                       @relation(fields: [assignedToEmail], references: [email])
  business                   Business?                      @relation(fields: [businessId], references: [id])
  incidentTicketNotification IncidentTicketNotification[]
  playbookRecommendations    TicketPlaybookRecommendation[]
  ResolveIncident            ResolveIncident?

  // New required fields
  source      Source @default(EMAIL)
  category    String
  subCategory String
  description String
  impact      Impact @default(LOW)
  MTTR        String // Time taken to raise incident

  // New optional fields
  suggestionFix  String?
  escalate       String?
  affectedSystem String?
  escalations    EscalatedIncident[]
  intel          Intel[]

  Imssetup Imssetup[]
}

// ===================== END INCIDENT TICKET ==================

model EscalatedIncident {
  id                String           @id @default(uuid())
  incidentTicketId  String
  escalatedToUserId String
  escalatedById     String
  escalationReason  String?
  escalatedAt       DateTime         @default(now())
  status            EscalationStatus @default(PENDING)

  // Relations
  incidentTicket  IncidentTicket @relation(fields: [incidentTicketId], references: [id], onDelete: Cascade)
  escalatedToUser User           @relation("UserEscalatedTo", fields: [escalatedToUserId], references: [id])
  escalatedByUser User           @relation("UserEscalatedBy", fields: [escalatedById], references: [id])

  @@index([incidentTicketId])
  @@index([escalatedToUserId])
  @@index([escalatedById])
}

model Intel {
  id               String   @id @default(uuid())
  incidentTicketId String
  intelType        String
  details          String
  createdAt        DateTime @default(now())

  incidentTicket IncidentTicket @relation(fields: [incidentTicketId], references: [id], onDelete: Cascade)

  @@index([incidentTicketId])
}

model SLABreachAuditLog {
  id                    String         @id @default(uuid())
  slaType               SLABreachType
  breachedAt            DateTime
  breachDurationMinutes Int
  incidentId            String
  incident              IncidentTicket @relation(fields: [incidentId], references: [id])
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt

  @@index([incidentId])
  @@index([slaType])
  @@index([createdAt])
}

model IncidentTicketNotification {
  id         String   @id @default(uuid())
  business   Business @relation(fields: [businessId], references: [id])
  businessId String

  ticket   IncidentTicket @relation(fields: [ticketId], references: [id])
  ticketId String

  message   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Imssetup Imssetup[]
}

model UserThirdpartyIntegration {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id])

  businessId String?
  business   Business? @relation(fields: [businessId], references: [id])

  provider BusinessNotificationChannels

  accessToken  String?
  refreshToken String?

  metadata Json?

  assignedToEmail String? // assign incident raised automatically by default
  assignedTo      Invites? @relation(fields: [assignedToEmail], references: [email])

  defaultTarget String?

  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  Imssetup  Imssetup[]

  @@unique([userId, provider], name: "userId_provider")
}

model Conversation {
  id               String                    @id @default(uuid())
  incidentTicketId String                    @unique
  createdAt        DateTime                  @default(now())
  updatedAt        DateTime                  @updatedAt
  incidentTicket   IncidentTicket            @relation(fields: [incidentTicketId], references: [id])
  participants     ConversationParticipant[]
  messages         Message[]
}

model Message {
  id             String       @id @default(uuid())
  conversationId String
  senderId       String
  content        String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  sender         User         @relation(fields: [senderId], references: [id])
}

model ConversationParticipant {
  id             String       @id @default(uuid())
  conversationId String
  userId         String
  joinedAt       DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  user           User         @relation(fields: [userId], references: [id])
}

model EzraRule {
  id          String   @id @default(cuid())
  description String
  metric      String
  threshold   Int
  timeWindow  String
  actions     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model ProjectConfiguration {
  id          String        @id @default(uuid())
  name        String
  enviroment  String
  domain      String?
  description String?
  lastseen    DateTime      @default(now())
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  ownerId     String
  modules     String[]
  package     PackageModule
  owner       User          @relation(fields: [ownerId], references: [id])

  @@unique([ownerId, package])
  @@index([ownerId])
}

model Customer {
  id           String    @id @default(uuid())
  name         String?
  contactEmail String    @unique
  tenantId     String    @unique
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  isActive     Boolean   @default(true)
  stripeCustomerId String? // Add this field

  contracts    Contract[]
  incidents    Incident[]
  events       SecurityEvent[]
  users        User[]          @relation("CustomerToUser")
  subscriptions Subscription[] // Add this relation if not already present
}

model IncidentComment {
  id               String          @id @default(uuid())
  content          String
  isInternal       Boolean         @default(true)
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  authorId         String
  incidentTicketId String?
  isBusinessOwner  Boolean         @default(false)
  author           User            @relation(fields: [authorId], references: [id])
  IncidentTicket   IncidentTicket? @relation(fields: [incidentTicketId], references: [id])

  @@index([incidentTicketId])
  @@index([authorId])
}

model PlaybookExecution {
  id            String         @id @default(uuid())
  name          String
  status        PlaybookStatus @default(RUNNING)
  startedAt     DateTime       @default(now())
  endedAt       DateTime?
  logs          Json
  steps         Json
  parameters    Json
  incidentId    String
  initiatedById String?
  incident      Incident       @relation(fields: [incidentId], references: [id])
  initiatedBy   User?          @relation(fields: [initiatedById], references: [id])
  playbookId    String?
  playbook      Playbook?      @relation(fields: [playbookId], references: [id])

  @@index([incidentId])
  @@index([status])
  @@index([startedAt])
}

model Contract {
  id           String        @id @default(uuid())
  customerId   String
  serviceLevel AgreementType
  startDate    DateTime
  endDate      DateTime
  isActive     Boolean       @default(true)
  customer     Customer      @relation(fields: [customerId], references: [id])

  @@index([customerId])
}

model DetectionRule {
  id                   String                @id @default(uuid())
  name                 String                @unique
  description          String
  condition            Json
  query                String?
  severity             DetectionRuleSeverity @default(MEDIUM)
  status               DetectionRuleStatus   @default(DRAFT)
  type                 DetectionRuleType
  source               DetectionRuleSource   @default(CUSTOM)
  mitreTactics         String[]
  mitreTechniques      String[]
  version              Int                   @default(1)
  whocreated           String
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  createdById          String
  updatedById          String?
  interval             Int                   @default(3600)
  lastExecuted         DateTime?
  isActive             Boolean               @default(true)
  falsePositives       String[]
  mitigation           String?
  references           String[]
  tags                 String[]
  platform             DetectionRulePlatform @default(CUSTOM)
  autoGenerateIncident Boolean               @default(false)
  alerts               Alert[]
  updatedBy            User?                 @relation(fields: [updatedById], references: [id])

  @@index([severity])
  @@index([status])
  @@index([type])
  @@index([source])
  @@index([createdById])
  @@index([isActive])
  @@index([lastExecuted])
}

// ===========PLAYBOOK=======================
model Playbook {
  id          String   @id @default(uuid())
  name        String   @unique
  title       String
  description String?
  steps       Json? // Array of step strings
  tags        String[]
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  playbookRecommendations TicketPlaybookRecommendation[]
  playbookExecutions      PlaybookExecution[]
}

model TicketPlaybookRecommendation {
  id          String   @id @default(uuid())
  ticketId    String
  playbookId  String
  recommended Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Relations
  ticket   IncidentTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  playbook Playbook       @relation(fields: [playbookId], references: [id], onDelete: Cascade)

  @@unique([ticketId, playbookId])
}




// ====================END CUSTOMER MODELS====================

model EndCustomer {
  id           String    @id @default(uuid())
  name         String?
  contactEmail String    @unique
  tenantId     String    @unique
  passwordHash String?
  isVerified   Boolean   @default(false)
  isActive     Boolean   @default(true)
  lastLogin    DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  incidents   EndCustomerIncident[]
  comments    EndCustomerIncidentComment[]
  User User[]
  companyUserId String
  companyUser   User   @relation("CompanyUserToCustomers", fields: [companyUserId], references: [id])
  @@map("end_customers")
}

model EndCustomerIncident {
  id               String           @id @default(uuid())
  ticketNumber     String           @unique
  shortDescription String
  description      String
  priority         Priority         @default(MEDIUM)
  category         String
  status           IncidentStatus   @default(OPEN)
  customerId       String
  companyUserId    String
  businessId       String?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  resolvedAt       DateTime?
  closedAt         DateTime?

  // SLA targets
  slaTargetResponse DateTime?
  slaTargetResolve  DateTime?

  // Relations
  customer    EndCustomer                @relation(fields: [customerId], references: [id])
  companyUser User                       @relation(fields: [companyUserId], references: [id])
  business    Business?                  @relation(fields: [businessId], references: [id])
  comments    EndCustomerIncidentComment[]
  attachments EndCustomerIncidentAttachment[]

  @@map("end_customer_incidents")
}

model EndCustomerIncidentComment {
  id         String                       @id @default(uuid())
  content    String
  isInternal Boolean                      @default(false)
  authorType EndCustomerCommentAuthorType
  authorId   String
  incidentId String
  createdAt  DateTime                     @default(now())
  updatedAt  DateTime                     @updatedAt

  // Relations
  incident EndCustomerIncident @relation(fields: [incidentId], references: [id])

  @@map("end_customer_incident_comments")
  EndCustomer EndCustomer[]
}

model EndCustomerIncidentAttachment {
  id           String  @id @default(uuid())
  filename     String
  originalName String
  mimeType     String
  size         Int
  path         String
  incidentId   String
  createdAt    DateTime @default(now())

  // Relations
  incident EndCustomerIncident @relation(fields: [incidentId], references: [id])

  @@map("end_customer_incident_attachments")
}

enum EndCustomerCommentAuthorType {
  CUSTOMER
  USER
}






// =================ON CALL MODELS=======================

// Update the existing models or create new ones:

model OnCallAssignment {
  id          String        @id @default(uuid())
  date        DateTime      // Single date instead of date range
  status      OnCallStatus  @default(ACTIVE)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  teamMembers OnCallTeamMember[]
  
  @@index([date])
  @@index([status])
}

model OnCallTeamMember {
  id               String           @id @default(uuid())
  assignmentId     String
  memberId         String
  startTime        String           // Format: "HH:mm"
  endTime          String           // Format: "HH:mm"
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  
  assignment       OnCallAssignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  member           User             @relation(fields: [memberId], references: [id])
  
  @@unique([assignmentId, memberId])
  @@index([memberId])
}







// =================ENUMS=======================



// Add to your existing enums
enum OnCallStatus {
  ACTIVE
  INACTIVE
  COMPLETED
}



enum EscalationStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum GraphType {
  MULTIPLE_FAILED_LOGINS
  UNUSUAL_LOCATIONS
  HIGH_VELOCITY_PASSWORD_GUESS
  IP_ADDRESSES_TARGETING_MULTIPLE_ACCOUNTS
  GEOGRAPHICALLY_IMPOSSIBLE_LOGINS
  TRAVEL_VELOCITY_ANALYSIS
}

enum ResetTokenType {
  VERIFICATION_CODE
  RESET_LINK
}

enum Role {
  USER
  ADMIN
  CUSTOMER
  INTEGRATION
  MANAGER
  ANALYST
  VIEWER
}

enum AlertStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  SUPPRESSED
}

enum PlaybookStatus {
  RUNNING
  COMPLETED
  FAILED
  TERMINATED
}

enum DetectionRuleSeverity {
  INFO
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum DetectionRuleStatus {
  DRAFT
  ACTIVE
  DISABLED
  TESTING
  DEPRECATED
}

enum DetectionRuleType {
  THRESHOLD
  ANOMALY
  CORRELATION
  STATIC
  MACHINE_LEARNING
  IOC
  BEHAVIORAL
}

enum DetectionRuleSource {
  CUSTOM
  MITRE
  VENDOR
  COMMUNITY
  GOVERNMENT
}

enum DetectionRulePlatform {
  CUSTOM
  AZURE
  AWS
  GCP
  CROWDSTRIKE
  SNORT
  SURICATA
  ELK
  SPLUNK
}

enum AgreementType {
  BASIC
  ENTERPRISE
  GOVERNMENT
}

enum IncidentStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
  ON_HOLD
  ACKNOWLEDGED
  INVESTIGATION
  MITIGATED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
  INFORMATIONAL
}

enum Roles {
  CISO
  SECURITY_ENGINEER
  SOC_ANALYST
  IT_MANAGER
  OTHERS
}

enum AccountType {
  DEVELOPER
  BUSINESS
}

enum OAuthProvider {
  GOOGLE
  AWS
  GITHUB
  GITLAB
  AZURE
}

enum AccessPermissions {
  VIEW_DASHBOARD
  MODIFY_DASHBOARD
  EXECUTE_ACTIONS
  MANAGE_USERS
}

enum DashboardType {
  SCRUBBE_DASHBOARD_SIEM
  SCRUBBE_DASHBOARD_SOUR
  CUSTOM
}

enum BusinessPrefferedIntegration {
  JIRA
  FRESH_DESK
  SERVICE_NOW
}

// should be renamed to ThirdPartIntegrations
enum BusinessNotificationChannels {
  SLACK
  MICROSOFT_TEAMS
  SMS
  EMAIL
  GOOGLE_MEET
  ZOOM
  PAGERDUTY
  GITHUB
  GITLAB
  WHATSAPP
}

enum PackageModule {
  FINGERPRINT
}

enum IncidentTemplate {
  NONE
  PHISHING
  MALWARE
}

enum APIkeyEnvironment {
  DEVELOPMENT
  PRODUCTION
}

enum DetermineAction {
  LOCK_ACCOUNT
  NOTIFY_ANALYST
  QUARANTINE
  TERMINATE_SESSION
}

enum InviteStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum SLABreachType {
  ACK
  RESOLVE
}

enum SLAStatus {
  PENDING
  MET
  BREACHED
}

// for postmartum(incident resolve)
enum CauseCategory {
  SOFTWARE_BUG
  NETWORK_ISSUE
  HUMAN_ERROR
  DATA_BREACH
}

enum FollowUpStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
  DEALT_WITH
}

enum COMMUNICATION_CHANNEL {
  EMAIL
  SLACK
  PUBLIC_ANNOUNCEMENT
  CUSTOMER_PORTAL
}

enum Status {
  OPEN
  ACKNOWLEDGED
  INVESTIGATION
  MITIGATED
  RESOLVED
  CLOSED
}

enum Source {
  EMAIL
  SLACK
  PORTAL
  PHONE
  OTHERS
  HIGH
  CRITICAL
}

enum Impact {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}
